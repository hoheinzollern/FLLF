\documentclass[oneside]{amsart}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsthm}
\usepackage{amstext}
\usepackage{stmaryrd}
\input{prooftree}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\numberwithin{equation}{section}
\numberwithin{figure}{section}
\theoremstyle{plain}
\newtheorem{thm}{Teorema}
  \theoremstyle{definition}
  \newtheorem{xca}[thm]{Esercizio}

\makeatother

\usepackage[italian]{babel}

\begin{document}

\section*{Fondamenti Logici dei Linguaggi Funzionali a.a. 2010-2011}

\begin{xca}
Dimostrare che la funzione somma non è programmabile con un linguaggio dotato solo di:
\begin{itemize}
\item $Z^{1}$ (zero)
\item $S^{1}$ (successore)
\item $P_{i}^{n}$ (proiezioni)
\item $C^{n}$ (composizione)
\end{itemize}
\end{xca}

\begin{xca}
Date le seguenti definizioni di termini, scrivere il lambda termine
per la funzione predecessore (molto difficile) e per la funzione $IsZero$ (facile):
\begin{itemize}
\item $true = \lambda x.\lambda y.x $
\item $false = \lambda x.\lambda y.y $
\item $0 = \lambda y.\lambda x.x $
\item $S = \lambda z.\lambda y.\lambda x.y(z(y)(x)) $
\item $ITE = \lambda z.\lambda x.\lambda y.z(x)(y)$
\end{itemize}
\end{xca}

\begin{xca}
Scrivere il predecessore attraverso le funzioni $1 \mapsto 2$ e $2 \mapsto 1$ che
convertono la rappresentazione del precedente esercizio nella seguente: (probabilmente
non fattibile)
\begin{itemize}
\item $\langle M,N\rangle={\lambda}z.z(M)(N)$
\item $\pi_{1}(c)=c(true)$
\item $\pi_{2}(c)=c(false)$
\item $0={\lambda}x.x$
\item $S={\lambda}z.\langle false,z\rangle$
\item $IsZero={\lambda}z.\pi_{1}(z)$
\end{itemize}
\end{xca}

\begin{xca}
Dimostrare che la relazione $\beta^{*}$ definita come chiusura transitiva
di $\beta^{=}$ è la stessa definita con con R transitiva. (???)
\end{xca}

\begin{xca}
Dimostrare che $\rightarrow^{*} = \underset{\rightarrow^{=} \subseteq \mathcal{R}}{\bigcap} \mathcal{R}$,
dove $\mathcal{R}$ è una relazione transitiva e $\rightarrow^{=}$ è la chiusura riflessiva
della relazione di $\beta$-riduzione.
\end{xca}

\begin{xca}
Dimostrare che se $M \rightarrow_1 M'$ e $N \rightarrow_1 N'$, allora $M[x:=N] \rightarrow_1 M'[x:=N']$.
\end{xca}

\begin{xca}
Dimostrare che se ${\lambda}x.M \rightarrow_1 N$, allora
$N \equiv {\lambda}x.M'$ e $M \rightarrow_1 M'$.
\end{xca}

\begin{xca}
Sia $\llbracket\cdot\rrbracket$ un'interpretazione in un'algebra combinatoria. Verificare
che $\llbracket {\lambda}x.M(N) \rrbracket = \llbracket M[x:=N] \rrbracket$.
\end{xca}

\begin{xca}
Trovare un'interpretazione del combinatore di punto fisso $Y$ in un'algebra combinatoria.
\end{xca}

\begin{xca}
Scrivere un algoritmo che inferisca tipo e contesto per lambda termini.
\end{xca}

\begin{xca}
Mostrare che $\underset{S \in \mathcal{SAT}}{\bigcap}S \neq \mathcal{FN}$.
\end{xca}

\begin{xca}
Dimostrare il teorema di preservazione della $\beta$-riduzione:
\[ \forall \; M \; s.t. \; {\Gamma \vdash M:\alpha}, \; \forall \;
M' s.t. \; M\rightarrow_\beta M' \quad\text{allora}\quad \Gamma \vdash M':\alpha \]
\end{xca}

\begin{xca}
Dimostrare che il teorema di confluenza continua a valere su lambda termini tipabili.
\end{xca}

\begin{xca}
Dimostrare che l'intersezione arbitraria di saturi è un saturo.
\end{xca}

\begin{xca}
Nella sola ipotesi di monotonia, mostrare come si trova il massimo
punto fisso per i saturi.
\end{xca}

\begin{xca}
Dimostrare che $\llbracket\alpha\times\beta\rrbracket_{max} \in \mathcal{SAT}$
usando direttamente la definizione di insieme saturo.
\end{xca}

\begin{xca}
Mostrare che $\llbracket\alpha\times\beta\rrbracket_{min}$ e
$\llbracket\alpha\times\beta\rrbracket_{max}$ non coincidono.
\end{xca}

\begin{xca}
Dimostrare il teorema di validità per il tipo prodotto cartesiano.
\end{xca}

\begin{xca}
Estendere l'algoritmo di type inference alle coppie.
\end{xca}

\begin{xca}
Verificare che $\llbracket b[x:=a] \rrbracket = \llbracket b\rrbracket[x:=\llbracket a\rrbracket]$.
\end{xca}

\end{document}
